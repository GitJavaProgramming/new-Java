Java中的线程
查看UML类图结构

线程 -- Thread类
Thread.State---查阅源码
NEW
至今尚未启动的线程处于这种状态。
RUNNABLE
正在 Java 虚拟机中执行的线程处于这种状态。
可运行线程的线程状态。处于可运行状态的某一线程正在 Java 虚拟机中运行，但它可能正在等待操作系统中的其他资源，比如处理器。
BLOCKED
受阻塞并等待某个监视器锁的线程处于这种状态。
受阻塞并且正在等待监视器锁的某一线程的线程状态。处于受阻塞状态的某一线程正在等待监视器锁，以便进入一个同步的块/方法，或者在
调用 Object.wait 之后再次进入同步的块/方法。
WAITING
无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。
某一等待线程的线程状态。某一线程因为调用下列方法之一而处于等待状态：
    不带超时值的 Object.wait
    不带超时值的 Thread.join
    LockSupport.park
处于等待状态的线程正等待另一个线程，以执行特定操作。 例如，已经在某一对象上调用了 Object.wait() 的线程正等待另一个线程，以便
在该对象上调用 Object.notify() 或 Object.notifyAll()。已经调用了 Thread.join() 的线程正在等待指定线程终止。
TIMED_WAITING
等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。
具有指定等待时间的某一等待线程的线程状态。某一线程因为调用以下带有指定正等待时间的方法之一而处于定时等待状态：
    Thread.sleep
    带有超时值的 Object.wait
    带有超时值的 Thread.join
    LockSupport.parkNanos
    LockSupport.parkUntil
TERMINATED
已退出的线程处于这种状态。

中断初探
public void interrupt() 发起中断，线程中可中断方法阻塞时被中断会重置中断状态，否则将设置中断状态
public boolean isInterrupted() 测试是否中断
public static boolean interrupted() 测试当前线程是否中断，清除中断状态

synchronized
内置锁，独占锁，隐式锁
在Java对象头记录锁状态，Java中任何一个对象都有一个monitor与之关联，JVM进步/退出同步块通过monitorenter、monitorexit指令实现。
在代码块释放前其他想要获取该监视器锁的线程将会被阻塞挂起。
退出修饰的方法/代码块就会释放锁

必须从同步环境内调用wait()、notify()、notifyAll()方法。线程不能调用对象上等待或通知的方法，除非它拥有那个对象的锁。
void notify() 唤醒在此对象监视器上等待的单个线程。
void notifyAll() 唤醒在此对象监视器上等待的所有线程。
void wait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。当在对象上调用wait()方法时，执行该代码的线程立即放弃它在对象上的锁。
void wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。
void wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。


死锁
死锁产生的原因及四个必要条件
产生死锁的原因主要是：
    （1） 因为系统资源不足。
    （2） 进程运行推进的顺序不合适。
    （3） 资源分配不当等。
如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则
就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。
产生死锁的四个必要条件：
    （1） 互斥条件：一个资源每次只能被一个进程使用。
    （2） 占有与等待条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
    （3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
    （4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之
一不满足，就不会发生死锁。

死锁的避免：确定资源分配的安全性，安全序列与银行家算法。
死锁的检测与恢复...


Java内存模型
共享内存模型，

命令式编程中线程之间通信机制有两种：共享内存和消息（信号量）传递
Posix IPC（进程间通信）三种类型：
    Posix消息队列
    Posix信号量
    Posix共享内存区
Posix消息队列：有足够的写权限的线程可以往队列中放置消息，有足够的读权限的线程可以从队列中取走消息，异步的队列。
Posix信号量：用于进程/线程间同步
共享内存是可用IPC中最快的形式，因为一旦这样的内存映射到共享它的进程的地址空间中，这些进程间的数据传递就不再涉及内核。

java共享内存模型的规则 happens-before
JVM通过happens-before原则向程序员提供跨线程的内存可见性保证。
volatile的内存语义
    当写一个volatile变量时，JMM会把线程工作内存中的（共享的）volatile变量值立即刷新到主内存
    读一个volatile变量时，JMM会把线程本地内存的volatile变量置为无效，然后从主内存读取这个变量进行操作。

锁的内存语义
锁可以让临界区互斥执行
当线程释放锁时，JMM会把线程本地内存的共享变量刷新到共享（主）内存
当线程获取锁时，JMM会把线程本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量

final域的内存语义和指令重排序
as-if-serial语义
    单线程 不管怎么做重排序，程序执行结果都不能被改变
    多线程 对存在控制依赖的操作重排序，可能改变程序执行结果
编译器和处理器不会对存在数据依赖的两个内存操作做重排序
JMM--Java编译器在生成字节码时，会在执行指令序列的位置插入内存屏障来限制处理器的重排序
final域 略！！

CAS：利用处理器指令CMPXCHG实现，自旋CAS通过循环CAS操作直到操作成功为止。只能保证一个共享变量的原子操作。

参考资料
JAVA并发编程实践.pdf
JAVA并发编程的艺术.pdf
实战Java高并发程序设计（第2版）.pdf
Java并发编程之美.pdf
Java高并发编程详解：多线程与架构设计
Java多线程编程实战指南  核心篇.pdf
Java虚拟机规范  Java SE 8版
Java语言规范 基于 Java SE 8 中文
Unix网络编程卷2--进程间通信

















